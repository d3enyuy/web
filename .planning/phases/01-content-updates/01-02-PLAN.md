---
phase: 01-content-updates
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/blog.ts
  - components/blog.tsx
  - _posts/.gitkeep
autonomous: true
requirements:
  - CONT-04
  - CONT-05

must_haves:
  truths:
    - "Blog section on homepage displays posts from markdown files, not hardcoded array"
    - "Blog cards are clickable and link to /blog/[slug] routes"
    - "Clicking a blog card navigates to individual post page (even if 404 for now)"
  artifacts:
    - path: "lib/blog.ts"
      provides: "Blog data access layer with TypeScript types"
      exports: ["getBlogPosts", "BlogPost"]
      min_lines: 30
    - path: "components/blog.tsx"
      provides: "Blog section consuming dynamic blog data"
      contains: "import.*getBlogPosts"
    - path: "_posts/.gitkeep"
      provides: "Posts directory placeholder"
      min_lines: 1
  key_links:
    - from: "components/blog.tsx"
      to: "lib/blog.ts"
      via: "import and function call"
      pattern: "getBlogPosts\\(\\)"
    - from: "components/blog.tsx"
      to: "/blog/[slug]"
      via: "Next.js Link or anchor href"
      pattern: "href=.*blog/"
---

<objective>
Replace hardcoded blog data with dynamic content system that reads from markdown files and links to individual post routes.

Purpose: Enable content-driven blog management where posts are added as markdown files, preparing for full blog infrastructure in Phase 2. Homepage blog section becomes a dynamic preview of actual blog content.
Output: Blog data access layer, updated Blog component with links to post pages, and posts directory structure.
</objective>

<execution_context>
@/Users/dzenyuy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dzenyuy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/codebase/STRUCTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
@components/blog.tsx
</context>

<tasks>

<task type="auto">
  <name>Create blog data access layer</name>
  <files>lib/blog.ts</files>
  <action>
Create a new file `lib/blog.ts` that provides functions to read blog posts from markdown files.

**TypeScript Interface:**
```typescript
export interface BlogPost {
  slug: string
  title: string
  date: string
  readTime: string
  excerpt: string
  tags: string[]
  category: string
  content?: string // Optional, not needed for preview cards
}
```

**Function: `getBlogPosts(limit?: number): BlogPost[]`**
- Read markdown files from `_posts/` directory using Node.js `fs` module
- Parse frontmatter using `gray-matter` package (already available as dependency)
- Extract: title, date, excerpt, tags, category from frontmatter
- Calculate reading time based on word count (assume 200 words/min)
- Generate slug from filename (remove .md extension, kebab-case)
- Sort posts by date (newest first)
- Apply limit if provided (for homepage preview)
- Return array of BlogPost objects

**Fallback behavior:**
If `_posts/` directory doesn't exist or is empty, return the existing hardcoded posts array as fallback data (copy from current blog.tsx lines 7-44). This ensures the homepage doesn't break before markdown posts are added.

**Implementation notes:**
- Use synchronous file operations (`fs.readdirSync`, `fs.readFileSync`) since this runs at build time
- Filter for `.md` files only
- Handle missing frontmatter fields with sensible defaults (empty tags array, "uncategorized" category, etc.)
- Use path.join to construct file paths correctly across platforms

Follow Next.js conventions: server-side only code is safe here (no "use client" directive needed).
  </action>
  <verify>
    <automated>bun run build 2>&1 | grep -i "blog" || echo "Build completed"</automated>
    <manual>Check that lib/blog.ts exports getBlogPosts function and BlogPost type</manual>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>lib/blog.ts exists, exports getBlogPosts() and BlogPost interface, returns fallback data when no markdown files present</done>
</task>

<task type="auto">
  <name>Update Blog component to use dynamic data and link to post pages</name>
  <files>components/blog.tsx</files>
  <action>
Update `components/blog.tsx` to consume blog data from `lib/blog.ts` and make blog cards clickable links.

**Changes:**

1. **Remove hardcoded data:** Delete the `blogPosts` array (lines 7-44)

2. **Import and consume dynamic data:**
```typescript
import { getBlogPosts } from "@/lib/blog"

// Inside component:
const allPosts = getBlogPosts() // Gets all posts
```

3. **Add Next.js Link import:**
```typescript
import Link from "next/link"
```

4. **Update filtering logic:** Use `allPosts` instead of `blogPosts`
```typescript
const filteredPosts = selectedCategory === "all"
  ? allPosts
  : allPosts.filter((post) => post.category === selectedCategory)
```

5. **Wrap article cards in Link components:**
Change the `<article>` element to be wrapped in a `<Link>`:
```typescript
<Link key={index} href={`/blog/${post.slug}`} className="block">
  <article className="group cursor-pointer rounded-lg border border-border bg-card p-4 transition-all duration-300 hover:border-primary/50 hover:shadow-lg hover:shadow-primary/5 sm:p-6">
    {/* existing article content */}
  </article>
</Link>
```

6. **Preserve existing structure:** Keep all styling, category filtering, badge rendering unchanged.

**Note:** The /blog/[slug] route doesn't exist yet (Phase 2 work), so clicking links will show 404. This is expected and acceptable for Phase 1.
  </action>
  <verify>
    <automated>grep -n "import.*getBlogPosts" components/blog.tsx && grep -n "Link.*href.*blog" components/blog.tsx</automated>
    <manual>Visit homepage, verify blog cards display and are clickable (even if they 404)</manual>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>Blog component imports getBlogPosts, displays dynamic data, and each card links to /blog/[slug]</done>
</task>

<task type="auto">
  <name>Create posts directory structure</name>
  <files>_posts/.gitkeep</files>
  <action>
Create the `_posts/` directory in project root with a `.gitkeep` file to ensure the directory is tracked by git.

```bash
mkdir -p _posts
touch _posts/.gitkeep
```

This establishes the location where markdown blog posts will be stored starting in Phase 2. For Phase 1, the directory can be empty - the blog data layer will return fallback data.

**Why `_posts/` in root:**
- Follows Jekyll/Hugo/Gatsby conventions for content directories
- Underscore prefix indicates it's a content source, not a route
- Keeps content separate from code in `/components` and `/app`
  </action>
  <verify>
    <automated>ls -la _posts/.gitkeep</automated>
    <manual>Verify _posts directory exists in project root</manual>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>_posts/ directory exists with .gitkeep placeholder file</done>
</task>

</tasks>

<verification>
- [ ] lib/blog.ts exports getBlogPosts function and BlogPost type
- [ ] getBlogPosts returns fallback data when _posts/ is empty
- [ ] components/blog.tsx imports and calls getBlogPosts()
- [ ] Blog cards are wrapped in Next.js Link components
- [ ] Each blog card links to /blog/[slug] where slug is derived from post
- [ ] _posts/ directory exists in project root
- [ ] No TypeScript errors
- [ ] Build succeeds: `bun run build`
- [ ] Homepage blog section still displays posts (using fallback data)
</verification>

<success_criteria>
Homepage blog section displays posts dynamically from getBlogPosts() function (using fallback data initially). Each blog card is a clickable link pointing to /blog/[slug]. The _posts/ directory exists and is ready to receive markdown files in Phase 2. Build completes successfully with no errors.
</success_criteria>

<output>
After completion, create `.planning/phases/01-content-updates/01-02-SUMMARY.md`
</output>
